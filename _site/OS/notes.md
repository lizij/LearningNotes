# OS

[TOC]

# 内存管理

## 需求

1. 重定位

   现在操作系统中, 一个进程运行过程中可能会因为进程切换而在内存和磁盘中来回切换。如果没有重定位, 进程在重新回到内存来运行的时候, 就必须要加载到上一次在内存中运行的时候的同一段内存当中。这样对操作系统的管理来说是一个非常大的成本。

2. 保护

   主要是为了避免进程A通过各种手段读取或者修改了进程B的数据。

3. 共享

   在同一台机器上运行的多个进程, 势必会有不同进程要访问同一个内存块的需求。这里就需要共享内存的机制了。

   最典型的例子是, 当同一个二进制文件起了多个进程的时候, 访问二进制文件程序的时候, 最好是访问同一份, 而不是访问多份。

## 分区

内存分区要解决的问题就是一个进程所需要的内存到底是怎么在物理内存中给他分配的。历史上存在的一些方案整理如下：

| 方案         | 说明                                                         | 优势                                 | 劣势                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------ | ------------------------------------------------------------ |
| 固定分区     | 在系统初始化的时候, 将可用内存划分成数个大小相等或者不等的内存区域。每次进程运行的时候可以加载到某个大于自己所需内存的内存区域中。 | 实现简单, 只需要很少的操作系统开销   | 有大量的内存碎片, 内存利用不充分                             |
| 动态分区     | 同固定分区, 只是每次都在内存中动态分配一个跟进程所需内存一样大小的内存块用来装内存 | 没有内部碎片, 内存利用更充分         | 随着进程的启动和终止, 还是不可避免的会有碎片出现, 为了提高内存利用率, 又得增加压缩内存的处理进程, 在压缩过程中消耗巨大 |
| 简单分页     | 将主存划分为大小相同的小区块, 进程所需内存也划分为同样大小的区块。进程所需内存被装入到不一定连续的区块中。 | 没有外部碎片                         | 无                                                           |
| 简单分段     | 类似动态分区, 只是将进程分成数个段, 每个段单独申请一块内存   | 相比动态分区, 提高了内存利用效率     | 还是会有外部碎片以及内存整理的工作                           |
| 虚拟内存分页 | 跟简单分页一样, 只是不需要一次性将所有进程所需内存都加载到内存中, 按需索取 | 内存使用效率更高, 巨大的虚拟地址空间 | 复杂的内存管理                                               |
| 虚拟内存分段 | 跟简单分段类似, 但是不需要一次性加载所有分段, 按需加载       | 同虚拟内存分页                       | 复杂的内存管理                                               |

[操作系统之内存管理科普](http://www.cnblogs.com/xuanku/p/os_memory.html)